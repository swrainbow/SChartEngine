# SChartEngine
# 前言
任何一个合格，或者说想要提升自己的开发者，不能只会使用框架对不对？必然要对框架原理甚至源码做深入了解，才能有所成长。虽然看了canvas的api，但是怎么能做到echarts这样酷炫，完全没有头绪，只能徒生艳羡。所以就想了解它的原理和设计。

怎么去了解原理啊？实力强的看源码目录就了然于胸，实力弱的就只能看教程和分析了。实力强的多还是实力弱的多啊，那显然是弱的多。
第一反应就是搜啊，百度搜完谷歌搜。面向搜索学习有什么不对吗。诸位就会想了，既然这些框架的群众基础如此广泛，贡献者也这么多，相关分析应该不在少数吧？

我也是这么想的。

至于结果，大家应该都能猜到了，结果寥寥。只能搜到一些如何实现粒子效果，或者介绍某个canvas库和其使用方法的。当时就蒙了：你一直叫我进步我怎么进步啊，网上为什么没有教程啊？

那没办法，只能硬啃， 看一些零碎的文章配合Zrender源码， 自己动手实现一个简单的绘图引擎。

## 说明
代码大多参考市面上已有的绘图引擎 如Zrender， fabricjs等
我们采用Zrender的MVC架构，总体如下，命名可能微调
* Stroage(M) : shape数据CURD管理 （基本数据结构）
* Painter(V) : canvase元素生命周期管理，视图渲染，绘画，更新控制
* Handler(C) : 事件交互处理，实现完整dom事件模拟封装
* shape : 图形实体，分而治之的图形策略，可定义扩展
* tool : 绘画扩展相关实用方法，工具及脚手架
* animation : 动画扩展，提供promise式的动画接口和常用缓动函数

## 思路
### -
先从M 和 V 这两层说起。 M需要进行基本的增删改查的操作，基本的数据结构就是数组 存储需要绘制的elements元素，并且有add， del， update， get 方法。
V 需要有绘制基本图形的canvas api。设想一下，只是总是有类似的地方。如果canvas的图形也有zindex，你如何区分。你可能会思考，canvas并没有提供基本的zindex属性，我该如何绘制。仔细想下，图形的层级与它绘制的先后顺序有关，如果我们在绘制的时候，按照元素的层级属性排序，低的先绘制，高的后绘制，最后绘制出来的就是zindex低的被zindex高的挡住了，这就实现元素的zindex。这时候配合基本的api 首先就能实现简单的图形绘制。
### 二
再说说c这一层。control这一层主要是事件的监听。我们以click事件为例。如果要canvas上的元素需要触发click事件，总体上需要经过一下这两步。
- click事件坐标转换为canvas内部坐标
- 遍历所有元素是否包含坐标，然后触发事件

写起来很简单，但是实际操作起来很复杂。
关于是否包含坐标，canvas提供了isPointInPath以及isPointInStroke，但是性能差，20000次的目标检测 需要花费 60ms，而zrender只需要5ms。查看zrender源码可以发现，zrender对路径绘制做了一层代理，思想类似于vue 虚拟dom，通过路径数据检测是否包含该坐标。具体可以查看代码实现
### 三 其他
还有一些 动画，数学库，以及整体的架构设计模式，也都非常的巧妙，值得我们反复的观摩学习。



## 写在最后
希望有空能把matterjs 通过ts重新实现一遍。
长路漫漫 